% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/difeq.R
\name{difeq}
\alias{difeq}
\title{Solve difference equation}
\usage{
difeq(y, steps, target, parms, ..., t0 = 0, dt = 1, n_out = 0L,
  n_history = 0L, return_history = n_history > 0, dllname = "",
  parms_are_real = TRUE, ynames = TRUE, outnames = NULL,
  by_column = FALSE, return_initial = FALSE, return_step = FALSE,
  deSolve_compatible = FALSE)
}
\arguments{
\item{y}{The initial state of the system.  Must be a numeric vector}

\item{steps}{Either a vector of steps to solve the system at or a
positive integer.  If a vector of steps, then the \emph{first}
step is taken as step zero, and the solution will be recorded at
every other step in the vector.  So to step a system from time
zero to times 1, 2, 3, ... use 0:n.}

\item{target}{The target function to advance.  This can either be
an R function taking arguments \code{n, i, t, y, parms} or be a
scalar character with the name of a compiled function with
arguments \code{size_t n, size_t step, double time, const double
*y, double *dydt, size_t n_out, double *output void *data}.}

\item{parms}{Parameters to pass through to the difference function}

\item{...}{Dummy arguments - nothing is allowed here, but this
means that all further arguments \emph{must} be specified by
name (not order) so I can easily reorder them later on.}

\item{t0}{The initial time, if your problem has a continuous time
basis too (e.g., if each step corresponds to 1/365 of a year)}

\item{dt}{The continuous time step size}

\item{n_out}{Number of "output" variables (not differential
equation variables) to compute via the routine \code{output}.}

\item{n_history}{The number of iterations of history to save
during the simulation.  By default, no history is saved.}

\item{return_history}{Logical indicating if history is to be
returned.  By default, history is returned if \code{n_history}
is nonzero.}

\item{dllname}{Name of the shared library (without extension) to
find the function \code{func} in the case where \code{func}
refers to compiled function.}

\item{parms_are_real}{Logical, indicating if \code{parms} should
be treated as vector of doubles by \code{func} (when it is a
compiled function).  If \code{TRUE} (the default), then
\code{REAL(parms)}, which is \code{double*} is passed through.
If \code{FALSE} then if \code{params} is an externalptr type
(\code{EXTPTRSXP}) we pass through the result of
\code{R_ExternalPtrAddr}, otherwise we pass \code{params}
through unmodified as a \code{SEXP}.  In the last case, in your
target function you will need to include \code{<Rinternals.h>},
cast to \code{SEXP} and then pull it apart using the R API (or
Rcpp).}

\item{ynames}{Logical, indicating if the output should be named
following the names of the input vector \code{y}.
Alternatively, if \code{ynames} is a character vector of the
same length as \code{y}, these will be used as the output names.}

\item{outnames}{An optional character vector, used when
\code{n_out} is greater than 0, to name the model output matrix.}

\item{by_column}{Logical, indicating if the output should be
returned organised by column (rather than row).  This incurs a
slight cost for transposing the matrices.  If you can work with
matrices that are transposed relative to \code{deSolve}, then
set this to \code{FALSE}.}

\item{return_initial}{Logical, indicating if the output should
include the initial conditions (like deSolve).}

\item{deSolve_compatible}{Logical, indicating if we should run in
"deSolve compatible" output mode.  This enables the options
\code{by_column}, \code{return_initial} and \code{return_time}.
This affects only some aspects of the output, and not the
calculations themselves.}

\item{n_out}{The number of output variables (in addition to the
difference equation variables).  If given, then an R function
must return an \emph{attribute} \code{output} with the output
variables.}
}
\description{
Solve a difference (or recurrence) equation by iterating it a
number of times.
}

